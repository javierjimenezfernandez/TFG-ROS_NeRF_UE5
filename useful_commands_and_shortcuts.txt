
xTerminal (linux)
-----------------------------------------------------------------------
Shift+Ctrl+O 			to split the window horizontally
Shift+Ctrl+E 			to split the window vertically
Alt+arroy_keys 			to navigate between different terminals


catkin
-----------------------------------------------------------------------
catkin_make			to create the workspace if it doesn't
				exist and to compile it. It will compile
				every package code included in its src
				folder which is listed in its CMakeLists.txt

catkin_create_pkg [pkg_name]	to create a pkg. Typical dependencies are:
 [dependencies]			roscpp rospy and std_msgs


ROS
-----------------------------------------------------------------------
roscore				to initilize ROS

[ros_command] -h		to see a list of all the options available
				for [ros_command] and some useful information
				about the [ros_command]

rosnode list			to show currenntly initilized nodes
				/rosout will allways be running while
				roscore is active 

rosrun [package] [executable]	to run any node from anywhere (please
				make sure you roscore before). Once you
				write package name press TAB for 
				autocompletion features

rosnode info [node_name]	to see information about the node: topics
				to where the node is publishing or subscribed,
				services and connections

rosnode kill [node_name]	to kill a node (same as Ctrl+C in the
				window where the node is being executed)

rosnode ping [node_name]	to ping the node like a server to check
				is that node is in the graph and connected

rosrun rqt_graph rqt_graph	to show all the active nodes in a graph
 (also just rqt_graph)		and information about their interactions,
				where are they publishing... etc.

rosrun turtlesim [turlte_nodes]	testing package with nodes to test some
				ROS functionalities

rostopic list			shows all rostopics that are currently
				being published

rostopic echo [rostopic_name]	to listen to any rostopic from the command
				window

rostopic info [rostopic_name]	to show the type, the Publishers and
				Subscribers of the topic

rostopic pub -r [rate]		to publish a message with rate Hz (use TAB
 [rostopic_name] [data_type]	for autocompletion for data type and subtype)
 "[subtype]: '[message]'"

rosservice list			gives a list of current active services

rosservice call [service_name]	to directly call a service from the terminal,
 "[arg_1]: [value] ..."		press TAB for argument autocompletion

rosservice info [service_name]	it will give you which nodes are using the
				service, what is the type of the service file
				with the request and the response, and then the
				args, so basically the request you need to send
				to the service.

rosmsg [params]			command to work with message definition, to 
				interact with messages from the command line please 
				use rostopic.

rosmsg list			lists all messages available in the current
				ROS installation. To search for a specific one
				it is very useful to use the grep pipe.

rosmsg show [msg_name]		shows the defintion of the msg.

rossrv [params]			command to work with service definition, to
				interact with services from the command line please 
				use rosservice.

rossrv list			lists all services available in the current
				ROS installation. To search for a specific one
				it is very useful to use the grep pipe.

rossrv show [srv_name]		shows the definition of the service including
				request and response messages.


Notes about nodes
------------------------------------------------------------------------
Definition:

when you create a python node it has to be stored in the scripts folder
of your package and execution pemissions have to be enabled with:
chmod +x [file_name]
when you create a cpp node it has to be stored in the src folder inside
the package directory and added to the CMakeLists.txt to be compiled with:
catkin_make
catkin_make has to be performed in the father catkin_ws directory


Notes about Topics
------------------------------------------------------------------------
Definition: a topic is defined by two things: a name, which is the
interface to reach, and a message definition which is the data structure
of the information you send.

Custom messages can be created from scratch or using some already existing
primitive definitions in the ROS Wiki.

An interesting recommendation is that all message definitions are contained
in a message definition package, so when that message is needed you just
need to add a dependency to that package and you won't have a dependency mess.

ATTENTION: after compiling a new message package you will have to refresh
the cmd window (type: source .bashrc) or open a new one in order to use a 
node that have a dependency on the brand new message package.


Notes about services
------------------------------------------------------------------------
Definition: a service is also defined by two things: a name, which is the
interface to reach, and a service definiton. This service definition 
contains one message definition for the request and one message definition 
for the response.

Only one server can exist for every service, if you need multiple one you
will have to use prefixes like /turtle1/teleport, /turtle2/teleport etc.
You may have multiple clients for the same service.

When searching in ROS Wiki doc about service types you may find that there
are some arguments (or types) above three dashes and some below, like this:

int64 a
int64 b
---
int64 sum

So you have two message definitions separated by three dashes. The above are 
the types from the request message definition and the below ones the types 
from the response message definition.

